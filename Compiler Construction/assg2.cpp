///* Write all paths generated by NFA */
//
//#include <iostream>
//#include <string>
//#include <vector>
//
//using namespace std;
//
//// N states, transitions (input, state)
//// -1 is dead state
//vector< vector< vector<int> > > NFA = {
//	{ {0, 0}, {1, 0}, {1, 1} },
//	{ {0, 2}, {1, 2} },
//	{ {0, 3}, {1, 3} },
//	{ {0, -1}, {1, -1} }
//};
//
//vector<int> get_neighbours(int curr_state, int input)
//{
//	vector<int> neighbours;
//
//	for (auto i : NFA[curr_state])
//		if (i[0] == input)
//			neighbours.push_back(i[1]);
//
//	return neighbours;
//}
//
//int main(void)
//{
//	string input = "0100"; // default value
//	cout << "Enter a string to get all paths: ";
//	cin >> input;
//
//	vector<string> paths = { "0" };
//
//	for (int i = 0; i < input.length(); i++)
//	{
//		int x = paths.size();
//		for (int j = 0; j < x; j++)
//		{
//			int curr_state = paths[j][paths[j].length() - 1];
//
//			if (curr_state == 'x')
//				continue;
//			
//			vector<int> neighbours = get_neighbours(curr_state - '0', input[i] - '0');
//
//			if (neighbours.size() > 0)
//			{
//				// append all, except 1st, to the path but make separate copies, then add to new_paths
//				for (int k = 1; k < neighbours.size(); k++)
//				{
//					string new_path;
//					if (neighbours[k] != -1)
//						new_path = paths[j] + to_string(neighbours[k]);
//					else
//						new_path = paths[j] + 'x';
//
//					paths.push_back(new_path);
//				}
//
//				// append the first neighbour to the string
//				if (neighbours[0] != -1)
//					paths[j] = paths[j] + to_string(neighbours[0]);
//				else
//					paths[j] = paths[j] + 'x';
//			}
//		}
//	}
//	
//
//	// output
//	for (auto i : paths)
//	{
//		cout << i << endl;
//	}
//		
//	return 0;
//}